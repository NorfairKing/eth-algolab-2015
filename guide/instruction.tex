\documentclass[guide.tex]{subfiles}
\begin{document}


\section{Configuration}



\section{Solving a problem}

{\Huge

\begin{enumerate}
  \item Read the assignment until the formal specification.
  \item Write the IO while reading the formal specification.
  \item Come up with a model for the solution using the following pages.
\end{enumerate}

}

\begin{itemize}
\item Put this at every problem.
  \newline \cc{std::ios_base::sync_with_stdio(false);}
\item Compile with one of these commands:
  \newline \cl{cgal_create_cmake_script; cmake .; make}
  \begin{minted}{raw}
g++ -o main.bin main.cc
  -Wall -Werror
  -std=c++11
  -lm
  -lboost_system -lboost_graph -lboost_thread
  -lCGAL -lgmp -lmpfr -frounding-math -lCGAL_Core
  \end{minted}
\end{itemize}
\pagebreak

\section{Models}

% TODO order these by the part they're in.
\subsection{Greedy}
\begin{itemize}
  \item Make sure any local optimum is a global optimum.
  \item Define the 'best' guess.
\end{itemize}

\subsection{Divide and conquer}
\begin{itemize}
  \item Define how to divide.
  \item Define how to merge results.
\end{itemize}

\subsection{DFS}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
\end{itemize}

\subsection{BFS}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
\end{itemize}

\subsection{Minimum Spanning Tree}
\begin{itemize}
  \item Undirected graph.
  \item Define nodes.
  \item Define edges.
  \item Define edge costs.
\end{itemize}

\subsection{Graph coloring}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item Define colors.
\end{itemize}

\subsection{Graph matching}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item A matching in a graph is a set of edges without common vertices.
\end{itemize}

\subsection{Topological sort}
\begin{itemize}
  \item Directed graph.
  \item Define nodes.
  \item Define edges.
\end{itemize}

\subsection{Linear programming}
\begin{itemize}
  \item Define the objective function to minimize/maximize. Both the factors and the variables.
  \item Define the constraints.
\end{itemize}

\subsection{Network flow: Max flow}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item Define the source and the sink.
  \item Define flow capacity for each edge
\end{itemize}

\subsection{Network flow: Max flow/Min cost}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item Define the source and the sink.
  \item Define flow capacity for each edge.
  \item Define flow cost for each edge.
\end{itemize}

\subsection{Dynamic programming}
\begin{itemize}
  \item Optional: Define a recursive solution with no optimization
  \item Define the state to optimize.
\end{itemize}

\subsection{Biconnected components \& articulation points}
\begin{itemize}
  \item Define nodes
  \item Define edges.
\end{itemize}

\subsection{Delaunay/Voronoi}
\begin{itemize}
  \item Define points/sites.
  \item Define distances
    % What can I query quickly in voronoi/delaunay?
\end{itemize}

\subsection{Minimum enclosing shapes}
\begin{itemize}
  \item Define the points
\end{itemize}

\subsection{Scan}
\begin{itemize}
  \item Define the events
\end{itemize}

\subsection{Binary search}
\begin{itemize}
  \item Make sure that the collection is sorted.
  \item Make sure that you have random access in $O(1)$ time to the collection's elements
\end{itemize}

\subsection{Shortest paths}
\begin{itemize}
  \item TODO
\end{itemize}

\section{These snippets may come in handy}

\subsection{Floor and Ceil: regular}
\begin{minted}{c++}
double floor_to_double(const K::FT& x) {
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a+1 <= x) a += 1;
  return a;
}
\end{minted}

\begin{minted}{c++}
double ceil_to_double(const K::FT& x) {
  double a = std::ceil(CGAL::to_double(x));
  while (a < x) a += 1;
  while (a-1 >= x) a -= 1;
  return a;
}
\end{minted}

\subsection{Floor and Ceil: Sqrt}
\begin{minted}{c++}
double ceilsqrt(const K::FT &x) {
  const K::FT sqrtx = sqrt(x); // exact
  double a = floor(CGAL::to_double(sqrtx)); // not
  while (a > sqrtx) a -= 1; while (a < sqrtx) a += 1;
  return a;
}
\end{minted}

\begin{minted}{c++}
double floorsqrt(const K::FT& x) {
  const K::FT sqrtx = sqrt(x); // exact
  double a = std::floor(CGAL::to_double(sqrtx));
  while (a > sqrtx) a -= 1; while (a + 1 <= sqrtx) a += 1;
  return a;
}
\end{minted}


\begin{minted}{c++}

\end{minted}


\begin{minted}{c++}

\end{minted}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
