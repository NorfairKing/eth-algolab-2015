\documentclass[guide.tex]{subfiles}
\begin{document}


\section{Configuration}



\section{Solving a problem}

{\Huge

\begin{enumerate}
  \item Read the assignment until the formal specification.
  \item Write the IO while reading the formal specification.
  \item Come up with a model for the solution using the following pages.
\end{enumerate}

}

\begin{itemize}
\item Put this at every problem.
  \newline \cc{std::ios_base::sync_with_stdio(false);}
\item Compile with one of these commands:
  \newline \cl{cgal_create_cmake_script; cmake .; make}
  \begin{minted}{raw}
g++ -o main.bin main.cc
  -Wall -Werror
  -std=c++11
  -lm
  -lboost_system -lboost_graph -lboost_thread
  -lCGAL -lgmp -lmpfr -frounding-math -lCGAL_Core
  \end{minted}
\end{itemize}
\pagebreak

\section{Models}
\subsection{Greedy}
\begin{itemize}
  \item Make sure any local optimum is a global optimum.
  \item Define the 'best' guess.
\end{itemize}

\subsection{Divide and conquer}
\begin{itemize}
  \item Define how to divide.
  \item Define how to merge results.
\end{itemize}

\subsection{BFS}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item Define what 'visiting a node' means.
\end{itemize}

Use a queue to hold vertices that still need to be visited.
\begin{minted}{c++}
  #include <queue>
\end{minted}
Use a color to represent visitness: \cc{WHITE} represents unvisited, \cc{GRAY} represens 'on the queue' and \cc{BLACK} represents 'visited'.
If written like this, vertices will be initialized to \cc{WHITE} automatically.
\begin{minted}{c++}
  enum color { WHITE, GRAY, BLACK };
\end{minted}
This uses your own vertex representation, fill in \cc{V} with whatever you need.
Edges are not necessarily explicitly represented
\begin{minted}{c++}
  vector<color> visited(nr_vertices, WHITE);

  V start;
  // Initialize start

  queue<V> q;
  q.push(start);
  while (! q.empty()) {
    V& cur = q.front();
    q.pop()

    // Visit q
    for (/* all vertices that can be reached: */ V n) {
      if (visited[n] != WHITE) { continue; }
      q.push(n);
      visited[n] = GRAY;
    }
    visited[cur] = BLACK;
  }
\end{minted}

\subsection{DFS}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item Define what 'visiting a node' means.
\end{itemize}

Like BFS (see above) but with a stack:
\begin{minted}{c++}
  #include <stack>
  stack<V> s; // Initialize
  s.push(start);

  V& cur = s.top() // Get top element
  s.pop() // Remove top element

  s.push(n) // Add new elements to top
\end{minted}

\subsection{Minimum Spanning Tree}
\begin{itemize}
  \item Undirected graph.
  \item Define nodes.
  \item Define edges.
  \item Define edge costs.
\end{itemize}

\subsection{Graph coloring}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item Define colors.
\end{itemize}

\subsection{Graph matching}
\begin{itemize}
  \item Define nodes.
  \item Define edges.
  \item A matching in a graph is a set of edges without common vertices.
\end{itemize}

\subsection{Topological sort}
\begin{itemize}
  \item Directed graph.
  \item Define nodes.
  \item Define edges.
\end{itemize}

\subsection{Linear programming}
\begin{itemize}
  \item Define the objective function to minimize/maximize. Both the factors and the variables.
  \item Define the constraints.
\end{itemize}

\subsection{Network flow: Max flow}
\begin{itemize}
  \item Define nodes
  \item Define edges.
  \item Define the source and the sink.
  \item Define flow capacity for each edge
\end{itemize}

\subsection{Network flow: Max flow/Min cost}
\begin{itemize}
  \item Define nodes
  \item Define edges.
  \item Define the source and the sink.
  \item Define flow capacity for each edge.
  \item Define flow cost for each edge.
\end{itemize}

\subsection{Dynamic programming}
\begin{itemize}
  \item Optional: Define a recursive solution with no optimization
  \item Define the state to optimize.
\end{itemize}

\subsection{Delaunay/Voronoi}
\begin{itemize}
  \item Define points/sites.
  \item Define distances
    % What can I query quickly in voronoi/delaunay?
\end{itemize}

\subsection{Minimum enclosing shapes}
\begin{itemize}
  \item Define the points
\end{itemize}

\subsection{Scan}
\begin{itemize}
  \item Define the events
\end{itemize}

\subsection{Binary search}
\begin{itemize}
  \item Make sure that the collection is sorted.
  \item Make sure that you have random access in $O(1)$ time to the collection's elements
\end{itemize}

\subsection{Shortest paths}
\begin{itemize}
  \item TODO
\end{itemize}

\section{These snippets may come in handy}

\subsection{Floor and Ceil: regular}
\begin{minted}{c++}
double floor_to_double(const K::FT& x) {
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a+1 <= x) a += 1;
  return a;
}
\end{minted}

\begin{minted}{c++}
double ceil_to_double(const K::FT& x) {
  double a = std::ceil(CGAL::to_double(x));
  while (a < x) a += 1;
  while (a-1 >= x) a -= 1;
  return a;
}
\end{minted}

\subsection{Floor and Ceil: Sqrt}
\begin{minted}{c++}
double ceilsqrt(const K::FT &x) {
  const K::FT sqrtx = sqrt(x); // exact
  double a = floor(CGAL::to_double(sqrtx)); // not
  while (a > sqrtx) a -= 1; while (a < sqrtx) a += 1;
  return a;
}
\end{minted}

\begin{minted}{c++}
double floorsqrt(const K::FT& x) {
  const K::FT sqrtx = sqrt(x); // exact
  double a = std::floor(CGAL::to_double(sqrtx));
  while (a > sqrtx) a -= 1; while (a + 1 <= sqrtx) a += 1;
  return a;
}
\end{minted}


\begin{minted}{c++}

\end{minted}


\begin{minted}{c++}

\end{minted}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
